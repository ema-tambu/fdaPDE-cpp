load "ffrandom"
srandomdev(); // set a true ramdom seed 

string path = "../../../../../readMesh/data/emanuele/";
string meshName = "golfo";
int nDirichletNodes = 173;
bool setDirichlet = 1;
mesh Th = readmesh(path + meshName + "/mesh.mesh");

plot(Th, wait = 0);

cout.precision(17);

fespace Vh(Th, P1);  // mixed finite elements but with the same space for both variables
Vh fh, gh, vh; // one test function vh is enough for both FEMs

Vh Err;

int Ndofs = Vh.ndof;
cout << "\nNdofs = " << Ndofs << endl;

// Define the PDE parameters
real nu = 10.; //0.032890; //0.02187505;

real quadratureOrder = 7;
real stabParam = 0.;
real lambda = 0.15; //0.1305; //0.15;

// define number of locations in the domain
int nLocs = 63;

// define forcing term
func f = 0.; //0.01; 

// load the expected solution from SST file and cast it into an object of type Vh
// read SST field
ifstream inputSST(path + meshName + "/SST.txt");
real[int] vecSST(Th.nv);
for (int i = 0; i < Th.nv; i++){
    inputSST >> vecSST(i);
}
// transform vecSST from kelvin to celsius
for (int i = 0; i < Th.nv; i++){
    vecSST(i) = vecSST(i) - 273.15;
}
Vh expectedSST;
expectedSST[] = vecSST;

// import transport data and cast them into an object of type Vh
// read transport field
ifstream inputBetaX(path + meshName + "/Beta_X.txt");
real[int] vecBetaX(Th.nv);

ifstream inputBetaY(path + meshName + "/Beta_Y.txt");
real[int] vecBetaY(Th.nv);

for(int i = 0; i < Th.nv; i++){
	inputBetaX >> vecBetaX(i);
	inputBetaY >> vecBetaY(i);
}

Vh bx, by;

bx[] = vecBetaX;
by[] = vecBetaY;

// SUPG stabilization parameter
fespace Xh(Th, P0);
Xh tauK, normb;
normb = sqrt (bx^2 + by^2);
tauK = stabParam*0.5*hTriangle/(normb + 1.e-10);

// assemble matrices for block linear system
varf stiff(phiJ, phiI) =
    int2d(Th, qforder=quadratureOrder)(
        nu * (dx(phiJ)*dx(phiI) + dy(phiJ)*dy(phiI))
        + bx*dx(phiJ)*phiI + by*dy(phiJ)*phiI
    )
    + int2d(Th, qforder=quadratureOrder)(
        f * phiI
    );

varf stiffAdjoint(phiJ, phiI) =
    int2d(Th, qforder=quadratureOrder)(
        nu * (dx(phiJ)*dx(phiI) + dy(phiJ)*dy(phiI))
        - bx*dx(phiJ)*phiI - by*dy(phiJ)*phiI
    );

varf stiffStab(phiJ, phiI) =
    int2d(Th, qforder=quadratureOrder)(
        - tauK*nu*(dxx(phiJ) + dyy(phiJ))*(bx*dx(phiI) + by*dy(phiI))  // diffusion SUPG
        + tauK*(bx*dx(phiJ) + by*dy(phiJ))*(bx*dx(phiI) + by*dy(phiI)) // transport SUPG
    )
    + int2d(Th, qforder=quadratureOrder)(
        + tauK*f*(bx*dx(phiI) + by*dy(phiI))   // forcing SUPG
    );

varf stiffStabAdjoint(phiJ, phiI) =
    int2d(Th, qforder=quadratureOrder)(
        tauK*nu*(dxx(phiJ) + dyy(phiJ))*(bx*dx(phiI) + by*dy(phiI))  // diffusion SUPG
        + tauK*(bx*dx(phiJ) + by*dy(phiJ))*(bx*dx(phiI) + by*dy(phiI)) // transport SUPG
    );

varf mass(phiJ, phiI) = 
    int2d(Th, qforder = quadratureOrder)(
        phiJ*phiI
    );

varf massStab(phiJ, phiI) = 
    int2d(Th, qforder = quadratureOrder)(
        tauK*(phiJ)*(bx*dx(phiI) + by*dy(phiI))
    );

matrix A = stiff(Vh, Vh);

matrix Aadj = stiffAdjoint(Vh, Vh);

real[int] U = stiff(0, Vh);

matrix S = stiffStab(Vh, Vh);

matrix Sadj = stiffStabAdjoint(Vh, Vh);

real[int] Us = stiffStab(0, Vh);

matrix R = mass(Vh, Vh);

matrix S1 = massStab(Vh, Vh);

// print the dimensions of the matrices (check)
cout << "A = (" << A.n << "x" << A.m << ")" << endl;
cout << "Aadj = (" << Aadj.n << "x" << Aadj.m << ")" << endl;
cout << "S = (" << S.n << "x" << S.m << ")" << endl;
cout << "Sadj = (" << Sadj.n << "x" << Sadj.m << ")" << endl;
cout << "R = (" << R.n << "x" << R.m << ")" << endl;
cout << "S1 = (" << S1.n << "x" << S1.m << ")" << endl;

// read locations
real[int] locs(nLocs*2); //(x, y) * nLocs 
{
    ifstream file(path + meshName + "/locations_flattened.txt");
    string line;
    // Read by line.
    for (int k = 0; k < nLocs*2; k++){
        getline(file, line);
        locs(k) = atof(line);
    }
}

// build the matrices Psi and Xi and evaluate them at locations
cout << "building Psi and Xi..." << endl;
real t0 = time();

Vh u = 0; // handle function on the FEM space to evaluate lagrangian basis at locations
matrix Psi; Psi.resize(nLocs, Ndofs);
matrix Xi; Xi.resize(nLocs, Ndofs);
for (int i = 0; i < Ndofs; i++){
    u[][i] = 1; // set basis function i to 1
    //loop over locations 
    for (int j = 0; j < nLocs; j++){
        real xLoc = locs(2*j);
        real yLoc = locs(2*j+1);
        real PsiIJ = u(xLoc, yLoc);
        Psi(j, i) = PsiIJ;
        real XiIJ = - tauK(xLoc, yLoc) * lambda * (bx(xLoc, yLoc) * dx(u)(xLoc, yLoc) + by(xLoc, yLoc) * dy(u)(xLoc, yLoc));
        // if (XiIJ != 0.00000000000000000){ cout << "i = " << i << ", j = " << j << ", XiIJ = " << XiIJ << endl; }
        Xi(j, i) = XiIJ;
    }
    u[][i] = 0; // reset basis function i to 0
}
cout << "Psi = (" << Psi.n << "x" << Psi.m << ")" << endl;
cout << "Xi = (" << Xi.n << "x" << Xi.m << ")" << endl;

// read observations
cout << "importing observations..." << endl;
real[int] observations(nLocs);
{
    ifstream file(path + meshName + "/observations.txt");
    string line;
    // Read by line.
    for (int k = 0; k < nLocs; k++){
        getline(file, line);
        observations(k) = atof(line);
    }
}

real t1 = time();
cout << "time to build Psi and Xi = " << t1 - t0 << endl;
cout << "assembling linear system..." << endl;

// assemble the big matrix Sigma

matrix block11 = Psi + Xi;
block11 = Psi' * block11;
block11 = (1.0/(nLocs)) * block11;

matrix block12 = Aadj + Sadj;
block12 = lambda * block12;

matrix block21 = A + S;

matrix block22 = - R - S1;

real tblocks = time();
cout << "time to build blocks = " << tblocks - t1 << endl;

matrix Sigma = [[block11, block12], [block21, block22]];

real t2 = time();
cout << "time to assemble Sigma = " << t2 - t1 << endl;

// assemble the big vector b
real[int] b1(Ndofs);
b1 = 0.0;
matrix aux = Psi' + Xi';
aux = (1.0/(nLocs))*aux;
b1 = aux * observations;

real[int] b2(Ndofs);
b2 = U + Us;

real[int] b = [b1, b2];

real t3 = time();
cout << "time to assemble b = " << t3 - t2 << endl;

// Load Dirichlet nodes
ifstream dirichletNodesFile(path + meshName + "/dirichlet_nodes.txt");
int[int] dirichletNodesVec(Th.nv);
for(int i = 0; i < nDirichletNodes; i++){
    dirichletNodesFile >> dirichletNodesVec(i);
}

// set Dirichlet boundary conditions in the big system
if (setDirichlet){
cout << "setting Dirichlet b.c. in the block system..." << endl;
for (int i = 0; i < nDirichletNodes; i++){
    int currentDof = dirichletNodesVec(i);
    // cout << "setting Dirichlet b.c. to line = " << currentDof << endl;

    for (int k = 0; k < Ndofs; k++){
        Sigma(currentDof, k) = 0;           // block (1, 1)
        Sigma(currentDof, k + Ndofs) = 0;   // block (1, 2)

        Sigma(currentDof + Ndofs, k) = 0;   // block (2, 1)
        Sigma(currentDof + Ndofs, k + Ndofs) = 0;   // block (2, 2)
    }
    Sigma(currentDof, currentDof) = 1;
    Sigma(currentDof + Ndofs, currentDof + Ndofs) = 1;
    
    // set Dirichlet datum on rhs
    real boundaryDatum = expectedSST[][currentDof];
    // cout << "boundaryDatum = " << boundaryDatum << endl;
    // cout << "expectedVecSST = " << vecSST(currentDof) << endl;
    b(currentDof) = boundaryDatum; // temperature of the sea surface at the shorelines
    b(currentDof + Ndofs) = 0;
}
}

real t4 = time();
cout << "time to set Dirichlet b.c. = " << t4 - t3 << endl;

real[int] solution(Ndofs*2);
solution = 0.0;

set(Sigma, solver = UMFPACK);
// set(Sigma, solver = LU);

cout << "solving linear system..." << endl;
solution = Sigma^-1 * b;

real t5 = time();
cout << "time to solve linear system = " << t5 - t4 << endl;

fh[] = solution(0:Ndofs-1);
gh[] = solution(Ndofs:2*Ndofs-1);

plot([fh], value = 1, fill = 1, wait = 1, cmm = "fh");
// plot([gh], value = 1, fill = 1, wait = 1, cmm = "gh");

plot([expectedSST], value = 1, fill = 1, wait = 1, cmm = "expectedSST");

// compute fh - expectedSST to have an idea of the error
{
Vh error;
error[] = fh[] - expectedSST[];
// plot the error
plot([error], value = 1, fill = 1, wait = 1, cmm = "error");
}
// HERE WE SHOULD DO LEAVE ONE OUT CROSS VALIDATION

varf massErr(psiJ, psiI) = int2d(Th)(psiJ*psiI);
matrix M = massErr(Vh, Vh);
real[int] prod(Ndofs);

func real error(){
  // store increments in incr variables
  Err[] = expectedSST[];
  Err[] -= fh[];

  for (int i = 0; i < Ndofs; ++i)
    prod[i] = Err[][i]*Err[][i];

  real[int] temp(Ndofs);
  temp = M*prod;

  real err2 = 0;

  for (int i = 0; i< Ndofs; ++i)
      err2 += temp[i];

  return err2;
}

{
real err;
err = error();
cout << "error = " << err << endl;
}
// compute the RMSE
real rmse = 0;
for (int i = 0; i < Ndofs; i++){
    rmse += pow(vecSST(i) - solution(i), 2);
}
rmse = sqrt(rmse/Ndofs);
cout << "RMSE_"<< nLocs << " = " << rmse << endl;

//save model.f() in a file 
real[int] fhat = solution(0:Ndofs-1);
{
    ofstream file("./fhat.txt");
    file.precision(17);
    for (int k = 0; k < Ndofs; k++){
        file << fhat(k) << endl;
    }
}